---
slug: /how-to-simulate-io-faults-at-runtime
title: 'How to Simulate I/O Faults at Runtime'
authors: keaoyang
image: /img/blog/how-to-simulate-io-faults-at-runtime.jpg
tags: [Chaos Mesh, Chaos Engineering, Fault Injection]
---

![カオスエンジニアリング - ランタイムでI/O障害をシミュレートする方法](/img/blog/how-to-simulate-io-faults-at-runtime.jpg)

本番環境では、ディスク障害や管理者ミスなど様々な要因によりファイルシステム障害が発生する可能性があります。カオスエンジニアリングプラットフォームであるChaos Meshは、初期バージョンからファイルシステム内のI/O障害をシミュレートする機能をサポートしています。IOChaosカスタムリソース定義（CRD）を追加するだけで、ファイルシステムがどのように失敗しエラーを返すかを観察できます。

<!--truncate-->

しかし、Chaos Mesh 1.0以前では、この実験は容易ではなく、多くのリソースを消費する可能性がありました。ミューテーティングアドミッションウェブフックを通じてPodにサイドカーコンテナを注入し、`ENTRYPOINT`コマンドを書き換える必要がありました。障害が注入されていない場合でも、注入されたサイドカーコンテナはかなりのオーバーヘッドを引き起こしました。

Chaos Mesh 1.0ではこれが大きく変わりました。現在では、IOChaosを使用してランタイムでファイルシステムに障害を注入できます。これによりプロセスが簡素化され、システムオーバーヘッドが大幅に削減されました。このブログ記事では、サイドカーを使用せずにIOChaos実験を実装する方法を紹介します。

## I/O障害注入

ランタイムでI/O障害をシミュレートするには、プログラムが[システムコール](https://man7.org/linux/man-pages/man2/syscall.2.html)（読み取りや書き込みなど）を開始した後、コールリクエストがターゲットファイルシステムに到達する前に障害を注入する必要があります。これには2つの方法があります：

- Berkeley Packet Filter（BPF）を使用する方法。ただし、[遅延の注入には使用できません](https://github.com/iovisor/bcc/issues/2336)。
- ターゲットファイルシステムの前にChaosFSというファイルシステム層を追加する方法。ChaosFSはターゲットファイルシステムをバックエンドとして使用し、オペレーティングシステムからのリクエストを受け取ります。コールリンクは**ターゲットプログラムのシステムコール** -> **Linuxカーネル** -> **ChaosFS** -> **ターゲットファイルシステム**となります。ChaosFSはカスタマイズ可能なため、遅延やエラーを自由に注入できます。したがって、ChaosFSを選択しました。

しかし、ChaosFSにはいくつかの問題があります：

- ChaosFSがターゲットファイルシステム内のファイルを読み書きする場合、Pod設定で指定されたターゲットパスとは異なるパスにChaosFSを[マウント](https://man7.org/linux/man-pages/man2/mount.2.html)する必要があります。ChaosFSはターゲットディレクトリのパスにマウント**できません**。
- ターゲットプログラムの実行が開始される**前に**ChaosFSをマウントする必要があります。これは、新しくマウントされたChaosFSが、ターゲットファイルシステム内でプログラムによって新しく開かれたファイルにのみ有効になるためです。
- ChaosFSをターゲットコンテナの`mnt`名前空間にマウントする必要があります。詳細は[mount_namespaces(7) — Linuxマニュアルページ](https://man7.org/linux/man-pages/man7/mount_namespaces.7.html)を参照してください。

Chaos Mesh 1.0以前では、[ミューテーティングアドミッションウェブフック](https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/)を使用してIOChaosを実装していました。この技術により、上記の3つの問題に対処し、以下のことが可能になりました：

- ターゲットコンテナ内でスクリプトを実行し、ChaosFSのバックエンドファイルシステムのターゲットディレクトリを変更（例：`/mnt/a`から`/mnt/a_bak`へ）して、ChaosFSをターゲットパス（`/mnt/a`）にマウントできるようにしました。Podを起動するコマンドを変更（例：元のコマンド`/app`を`/waitfs.sh /app`に変更）。
- `waitfs.sh`スクリプトはファイルシステムが正常にマウントされたかどうかを継続的にチェックし、マウントされていれば`/app`を起動しました。
- Podに新しいコンテナを追加してChaosFSを実行させました。このコンテナはターゲットコンテナとボリューム（例：`/mnt`）を共有し、このボリュームをターゲットディレクトリ（例：`/mnt/a`）にマウントしました。また、このボリュームのマウントに対して[マウント伝播](https://kubernetes.io/docs/concepts/storage/volumes/#mount-propagation)を適切に有効化し、ホストへの共有とターゲットへのスレーブ伝播を可能にしました。

これらの3つのアプローチにより、プログラムの実行中にI/O障害を注入することが可能になりました。しかし、注入は決して便利とは言えませんでした：

- ボリューム全体ではなく、ボリュームのサブディレクトリにのみ障害を注入できました。回避策として、`mv`（名前変更）の代わりに`mount move`を使用してターゲットボリュームのマウントポイントを移動しました。
- イメージコマンドを暗黙的に使用するのではなく、Pod内で明示的にコマンドを記述する必要がありました。そうしないと、`/waitfs.sh`スクリプトがファイルシステムのマウント後にプログラムを正しく起動できませんでした。
- 対応するコンテナは、マウント伝播の適切な設定が必要でした。プライバシーとセキュリティの問題が潜在するため、ミューテーティングアドミッションウェブフックを介して設定を変更することは**できませんでした**。
- 注入設定は面倒でした。さらに悪いことに、設定が障害を注入できるようになった後で新しいPodを作成する必要がありました。
- プログラムの実行中にChaosFSを撤回できませんでした。障害やエラーが注入されていない場合でも、パフォーマンスが大きく影響を受けました。

## ミューテーティングアドミッションウェブフックなしでI/O障害を注入

ミューテーティングアドミッションウェブフックなしでこれらの難題を解決するにはどうすればよいでしょうか？そもそもなぜミューテーティングアドミッションウェブフックを使用してChaosFSを実行するコンテナを追加していたのかを考えてみましょう。それは、ファイルシステムをターゲットコンテナにマウントするためでした。

実際には別の解決策があります。Podにコンテナを追加する代わりに、まず`setns` Linuxシステムコールを使用して現在のプロセスの名前空間を変更し、その後`mount`コールを使用してChaosFSをターゲットコンテナにマウントできます。注入対象のファイルシステムが`/mnt`であると仮定すると、新しい注入プロセスは以下のようになります：

1. 現在のプロセスがターゲットコンテナのmnt名前空間に入るように`setns`を使用します。
2. `mount --move`を実行して`/mnt`を`/mnt_bak`に移動します。
3. ChaosFSを`/mnt`にマウントし、`/mnt_bak`をバックエンドとして使用します。

このプロセスが完了すると、ターゲットコンテナはChaosFSを介して`/mnt`内のファイルを開いたり、読み書きしたりします。これにより、遅延や障害がはるかに簡単に注入されます。しかし、まだ2つの疑問が残ります：

- ターゲットプロセスによって既に開かれているファイルをどのように処理するか？
- ファイルが開かれている間にファイルシステムをアンマウントできないため、プロセスをどのように回復させるか？

### 動的にファイルディスクリプタを置換

**ptraceは上記の2つの疑問を両方解決します。** ptraceを使用して、実行中の開かれたファイルディスクリプタ（FD）を置換し、現在の作業ディレクトリ（CWD）とmmapを置換できます。

#### ptraceを使用してトレーシーにバイナリプログラムを実行させる

[ptrace](https://man7.org/linux/man-pages/man2/ptrace.2.html)は強力なツールで、ターゲットプロセス（トレーシー）に任意のシステムコールやバイナリプログラムを実行させることができます。トレーシーにプログラムを実行させるために、ptraceはRIPが指すアドレスをターゲットプロセスに変更し、ブレークポイントをトリガーする`int3`命令を追加します。バイナリプログラムが停止したら、レジスタとメモリを復元する必要があります。

> **注:**
>
> [x86_64アーキテクチャ](https://en.wikipedia.org/wiki/X86_assembly_language)では、RIPレジスタ（命令ポインタとも呼ばれる）は常に次に実行されるディレクティブのメモリアドレスを指します。プログラムをターゲットプロセスのメモリ空間にロードするには：

1. ptraceを使用してターゲットプログラムでmmapを呼び出し、必要なメモリを割り当てます。
2. バイナリプログラムを新しく割り当てられたメモリに書き込み、RIPレジスタをそれに向けます。
3. バイナリプログラムが停止した後、munmapを呼び出してメモリセクションをクリーンアップします。

ベストプラクティスとして、大量のデータを書き込む必要がある場合、ptraceの`POKE_TEXT`書き込みを`process_vm_writev`に置き換えることがよくあります。これは`process_vm_writev`の方が効率的に動作するためです。

ptraceを使用することで、プロセスに自身のFDを置換させることができます。あとはその置換を実現する方法が必要です。その方法が`dup2`システムコールです。

#### `dup2`を使用してファイルディスクリプタを置換

`dup2`関数のシグニチャは`int dup2(int oldfd, int newfd);`です。これは古いファイルディスクリプタ（`oldfd`）のコピーを作成するために使用されます。このコピーは`newfd`というファイルディスクリプタ番号を持ちます。もし`newfd`が既に開いているファイルのファイルディスクリプタに対応している場合、そのファイルで既に開かれているファイルディスクリプタは自動的に閉じられます。

例えば、現在のプロセスが`/var/run/__chaosfs__test__/a`を開き、そのファイルディスクリプタが`1`であるとします。この開かれたファイルを`/var/run/test/a`に置き換えるために、このプロセスは以下の操作を実行します：

1. `fcntl`システムコールを使用して、`/var/run/__chaosfs__test__/a`の`OFlags`（`open`システムコールで使用されるパラメータ、例えば`O_WRONLY`など）を取得します。
2. `Iseek`システムコールを使用して、現在の`seek`位置を取得します。
3. `open`システムコールを使用して、同じ`OFlags`で`/var/run/test/a`を開きます。ファイルディスクリプタが`2`であると仮定します。
4. `Iseek`を使用して、新しく開かれたファイルディスクリプタ`2`の`seek`位置を変更します。
5. `dup2(2, 1)`を使用して、`/var/run/__chaosfs__test__/a`のファイルディスクリプタ`1`を新しく開かれたファイルディスクリプタ`2`で置き換えます。
6. ファイルディスクリプタ`2`を閉じます。

このプロセスが完了すると、現在のプロセスのファイルディスクリプタ`1`は`/var/run/test/a`を指すようになります。これにより、障害を注入できるようになり、ターゲットファイルに対する後続の操作はすべて[Filesystem in Userspace](https://en.wikipedia.org/wiki/Filesystem_in_Userspace)（FUSE）を経由します。FUSEは、UnixおよびUnix系オペレーティングシステムのためのソフトウェアインターフェースで、非特権ユーザーがカーネルコードを編集することなく独自のファイルシステムを作成できるようにします。

#### ターゲットプロセスに自身のファイルディスクリプタを置き換えさせるプログラムを書く

ptraceとdup2の機能を組み合わせることで、トレーサーがトレイシーに開かれたファイルディスクリプタを自身で置き換えさせることが可能になります。ここで、バイナリプログラムを書き、ターゲットプロセスにそれを実行させる必要があります：

> **注記:**
>
> 上記の実装では、以下のことを仮定しています：
>
> - ターゲットプロセスのスレッドはPOSIXスレッドであり、開かれたファイルを共有しています。
> - ターゲットプロセスが`clone`関数を使用してスレッドを作成する際、`CLONE_FILES`パラメータが渡されます。
>
> したがって、Chaos Meshはスレッドグループ内の最初のスレッドのファイルディスクリプタのみを置き換えます。

1. 上記の2つのセクションとsyscallディレクティブの使用法に従って、アセンブリコードを書きます。[こちら](https://github.com/chaos-mesh/toda/blob/1d73871d8ab72b8d1eace55f5222b01957193531/src/replacer/fd_replacer.rs#L133)にアセンブリコードの例があります。
2. アセンブラを使用してコードをバイナリプログラムに変換します。アセンブラとして[dynasm-rs](https://github.com/CensoredUsername/dynasm-rs)を使用します。
3. ptraceを使用してターゲットプロセスにこのプログラムを実行させます。プログラムが実行されると、ファイルディスクリプタが実行時に置き換えられます。

### 全体的な障害注入プロセス

以下の図は、全体的なI/O障害注入プロセスを示しています：

![障害注入プロセス](/img/blog/fault-injection-process.jpg)

<div style={{ margin: '1rem 0', fontStyle: 'italic', textAlign: 'center' }}> 障害注入プロセス </div>

この図では、各水平線は矢印の方向に実行されるスレッドに対応しています。**Mount/Umount Filesystem**および**Replace FD**タスクは慎重に順序付けられています。上記のプロセスを考慮すると、この配置は非常に理にかなっています。

## 次のステップ

実行時にI/O障害をシミュレートするための障害注入の実装方法について説明しました（[chaos-mesh/toda](https://github.com/chaos-mesh/toda)を参照）。しかし、現在の実装はまだ完全ではありません：

- 世代番号がサポートされていません。
- ioctlがサポートされていません。
- Chaos Meshはファイルシステムが正常にマウントされたかどうかを即座に判断しません。1秒後にのみ判断します。

Chaos Meshに興味があり、改善に協力したい場合は、[Slackチャンネル](https://slack.cncf.io/)に参加するか、[GitHubリポジトリ](https://github.com/chaos-mesh/chaos-mesh)にプルリクエストやイシューを投稿してください。

これはChaos Meshの実装に関するシリーズの最初の投稿です。他の種類の障害注入の実装方法について知りたい場合は、今後の投稿をお待ちください。